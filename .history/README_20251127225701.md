# Prostar Landing Page

## Umgebung (.env)

- Kopiere `/.env.example` zu `/.env.development` (Client) und `/.env.local` (Server), oder einfach zu `/.env` für einen schnellen Start.
- Fülle die Platzhalter (Stripe, SMTP, Datenbank) mit deinen lokalen Werten. Für E-Mail-Tests eignet sich MailHog/MailPit (`SMTP_HOST=localhost`, `SMTP_PORT=1025`).
- Wichtige Variablen:
  - `PORT` (Standard `3000`), `DEMO_MODE=true`
  - `DATABASE_URL` (z. B. `file:./tmp/dev.db` für SQLite lokal)
  - `STRIPE_PUBLIC_KEY`, `STRIPE_SECRET_KEY`, `STRIPE_WEBHOOK_SECRET`
  - `SMTP_*` und `EMAIL_FROM`
  - `VITE_API_BASE_URL` (Standard `http://localhost:3000/api`)

### Schnellstart

```zsh
pnpm install
pnpm dev
```

Die Dev-Umgebung startet Server und Vite; öffne `http://localhost:3000`.

## AI Modell aktivieren

- Standardmodell wird über `AI_MODEL` gesetzt (Default `claude-sonnet-4.5`).
- Provider via `AI_MODEL_PROVIDER` (z. B. `anthropic`).
- Zur Laufzeit verfügbar über `shared/aiConfig.ts` (`ACTIVE_AI_MODEL`).
- Beispiel in `.env.local`:

```env
AI_MODEL=claude-sonnet-4.5
AI_MODEL_PROVIDER=anthropic
```

## E-Mail Versand (Gmail App-Passwort)

- Trage lokal (nicht committen!) in `.env.local` ein:

```env
EMAIL_USER=info@prostarmarketing.de
EMAIL_PASSWORD=<16-stelliges App-Passwort ohne Leerzeichen>
EMAIL_FROM=Prostar <info@prostarmarketing.de>
```
- App-Passwort: Im Google Konto unter Sicherheit → App-Passwörter erstellt.
- Passwort niemals in Git committen. Für Team: nur verschlüsselt teilen.

Kurz: Kleines Vite + Express/tRPC Projekt mit Drizzle-DB und Stripe-Integration.

Entwicklerhinweis (kurz)

- Lesen: `.github/copilot-instructions.md` — Repo-spezifische Hinweise für Entwicklung und AI-Copiloten.
- Lokale Env-Beispiele: `.env.example` (kopieren zu `.env` und Werte ergänzen).

Wichtige Befehle (Makefile-Shortcuts verfügbar):

```bash
make install-pnpm   # versucht pnpm via corepack oder npm zu aktivieren
make install        # wie oben
make dev            # startet pnpm dev
make check          # TypeScript-Check
make build
make start
make test
make debug-collect  # führt tools/collect-debug.sh aus und erzeugt debug_bundle.tar.gz
```

CI: Ein GitHub Actions-Workflow (`.github/workflows/ci.yml`) führt `pnpm install`, `pnpm run check`, `pnpm test` und `pnpm build` bei Push/PR aus.

Weitere Informationen zur Beitragserstellung und PR-Checkliste: `CONTRIBUTING.md`.

Docker (schneller Weg, falls du Node/pnpm lokal nicht installieren willst)

```bash
# Build + Start im Container (erstmalig)
docker compose build --progress=plain
docker compose up

# Oder nur im Hintergrund
docker compose up -d

# Logs ansehen
docker compose logs -f

# Stopp
docker compose down
```

Hinweis: Der Container startet per Default `pnpm dev` (dev server + Vite). Die Quelle wird als Volume gemountet, du kannst also im Host weiter editieren.

Ein-Kommando-Start (falls du lieber nicht mehrere Befehle eintippst)

```bash
# Skript erkennt pnpm automatisch oder fällt auf Docker Compose zurück
./scripts/start.sh
```

## Sicherheit & Registrierung

### Rate Limiting

Ein einfaches In-Memory Rate Limiting schützt vor exzessiven Anfragen:

Variablen (in `.env` konfigurierbar):

```env
RATE_LIMIT_WINDOW=60000   # Zeitfenster in ms (Standard 60s)
RATE_LIMIT_MAX=10         # Max. Requests pro Fenster & Route
```

Für echte Produktion mit mehreren Instanzen sollte ein externer Store (Redis) genutzt werden.

### Captcha (Real Implementation)

**Wichtig:** Echte Captcha-Verifikation gegen Provider-APIs ist implementiert!

Unterstützte Provider:

- **Google reCAPTCHA v3**: Score-basiert (0.0-1.0), konfigurierbar via `RECAPTCHA_MIN_SCORE` (Standard: 0.5)
- **hCaptcha**: Success/Fail Verifikation

Konfiguration in `.env`:

```env
CAPTCHA_PROVIDER=recaptcha   # oder hcaptcha
CAPTCHA_SECRET=<DEIN_SECRET>
RECAPTCHA_MIN_SCORE=0.5      # nur für reCAPTCHA v3
```

**Frontend-Integration erforderlich:**

- reCAPTCHA v3: Site Key + `grecaptcha.execute()` zum Token generieren
- hCaptcha: Site Key + Widget zum Token generieren

Wenn keine Variablen gesetzt sind, wird Captcha-Check übersprungen (Development-Mode).

### Formular-Schutzmechanismen

Registrierung (`registration.create`) & Finalisierung (`registration.finalize`) enthalten:

- Honeypot-Feld (muss leer sein)
- Mindest-Ausfüllzeit (≥1.5–2 Sekunden)
- Einmalige Code-Nutzung (Statuswechsel auf `used`)

### Passwort-gestützte Accounts

Das Feld `passwordHash` wurde zur Tabelle `users` hinzugefügt für lokale Accounts (nicht OAuth). Migration ausführen:
```
pnpm run db:push
```

### Lokaler Login

Zusätzlich zum OAuth Flow steht ein lokaler Login zur Verfügung:
- Seite: `/login`
- tRPC Mutation: `localAuth.login` (Email + Passwort)
- Session-Cookie wird genauso signiert wie beim OAuth Callback (`COOKIE_NAME = app_session_id`).

Registrierungsablauf für lokalen Zugang:
1. Gratis-Kurs anmelden (`/kostenloser-kurs`) → Access-Code per E-Mail
2. Code finalisieren unter `/course-access` (Passwort setzen) → User + `passwordHash` gespeichert
3. Login unter `/login` → Weiterleitung auf `/course`

Hinweis: Für Produktion Passwort-Politik & Bruteforce-Schutz ergänzen (z. B. zusätzliche Rate Limits, Sperrlisten).

### Passwort zurücksetzen

Vollständiger Flow implementiert:

**Backend:**
- Service: `server/services/passwordResetService.ts`
  - Token-Generierung (UUID, 24h Gültigkeit)
  - In-Memory Cache-Speicherung (DB TODO)
  - Single-Use Enforcement
  - User-Enumeration-Schutz (immer Erfolg zurückmelden)
- Router: `server/routers/passwordReset.ts`
  - `request`: Token generieren + E-Mail senden (mit Captcha)
  - `reset`: Neues Passwort setzen (mit Captcha)
- Email: HTML-Template mit Reset-Link (`SITE_URL/reset-password?token=...&email=...`)

**Frontend:**
- `/forgot-password`: E-Mail-Eingabe + Token-Anforderung
- `/reset-password`: Token-Verifizierung + neues Passwort setzen
- Link "Passwort vergessen?" auf Login-Seite

**Konfiguration:**
```
SITE_URL=https://your-domain.com   # für Email-Links
RECAPTCHA_MIN_SCORE=0.5             # Score-Schwellenwert
```

**Sicherheit:**
- 24h Token-Ablauf
- Single-Use Tokens (nach Nutzung ungültig)
- Captcha-Verifikation bei Request + Reset
- Honeypot + Timing-Checks
- User-Enumeration-Schutz (kein Unterschied ob User existiert)


### Erweiterung für Produktion (Empfehlungen)
- ✅ **Erledigt**: Echte Captcha-Verifikation gegen Provider API (reCAPTCHA v3 + hCaptcha)
- Ersetze In-Memory Cache durch persistente DB Tabellen (Registrierungen + Reset Tokens + Access Logs)
- Füge Rate Limiting mit Redis (z. B. Token Bucket) hinzu für Multi-Instance Deployments
- Logging/Monitoring (z. B. Prometheus Exporter oder external APM)
- Passwort-Policy & Bruteforce-Limit für Login-Endpunkt erweitern
- Frontend: Captcha-Widgets integrieren (reCAPTCHA Site Key, hCaptcha Site Key)
- Email-Versand: Produktions-SMTP konfigurieren (nicht Gmail App-Passwort)
- SITE_URL auf Produktions-Domain setzen für korrekte Reset-Links

