# Prostar Landing Page

## Umgebung (.env)

- Kopiere `/.env.example` zu `/.env.development` (Client) und `/.env.local` (Server), oder einfach zu `/.env` für einen schnellen Start.
- Fülle die Platzhalter (Stripe, SMTP, Datenbank) mit deinen lokalen Werten. Für E-Mail-Tests eignet sich MailHog/MailPit (`SMTP_HOST=localhost`, `SMTP_PORT=1025`).
- Wichtige Variablen:
	- `PORT` (Standard `3000`), `DEMO_MODE=true`
	- `DATABASE_URL` (z. B. `file:./tmp/dev.db` für SQLite lokal)
	- `STRIPE_PUBLIC_KEY`, `STRIPE_SECRET_KEY`, `STRIPE_WEBHOOK_SECRET`
	- `SMTP_*` und `EMAIL_FROM`
	- `VITE_API_BASE_URL` (Standard `http://localhost:3000/api`)

### Schnellstart

```zsh
pnpm install
pnpm dev
```

Die Dev-Umgebung startet Server und Vite; öffne `http://localhost:3000`.

## AI Modell aktivieren

- Standardmodell wird über `AI_MODEL` gesetzt (Default `claude-sonnet-4.5`).
- Provider via `AI_MODEL_PROVIDER` (z. B. `anthropic`).
- Zur Laufzeit verfügbar über `shared/aiConfig.ts` (`ACTIVE_AI_MODEL`).
- Beispiel in `.env.local`:
	```env
	AI_MODEL=claude-sonnet-4.5
	AI_MODEL_PROVIDER=anthropic
	```

## E-Mail Versand (Gmail App-Passwort)

- Trage lokal (nicht committen!) in `.env.local` ein:
	```env
	EMAIL_USER=info@prostarmarketing.de
	EMAIL_PASSWORD=<16-stelliges App-Passwort ohne Leerzeichen>
	EMAIL_FROM=Prostar <info@prostarmarketing.de>
	```
- App-Passwort: Im Google Konto unter Sicherheit → App-Passwörter erstellt.
- Passwort niemals in Git committen. Für Team: nur verschlüsselt teilen.

Kurz: Kleines Vite + Express/tRPC Projekt mit Drizzle-DB und Stripe-Integration.

Entwicklerhinweis (kurz)

- Lesen: `.github/copilot-instructions.md` — Repo-spezifische Hinweise für Entwicklung und AI-Copiloten.
- Lokale Env-Beispiele: `.env.example` (kopieren zu `.env` und Werte ergänzen).

Wichtige Befehle (Makefile-Shortcuts verfügbar):

```bash
make install-pnpm   # versucht pnpm via corepack oder npm zu aktivieren
make install        # wie oben
make dev            # startet pnpm dev
make check          # TypeScript-Check
make build
make start
make test
make debug-collect  # führt tools/collect-debug.sh aus und erzeugt debug_bundle.tar.gz
```

CI: Ein GitHub Actions-Workflow (`.github/workflows/ci.yml`) führt `pnpm install`, `pnpm run check`, `pnpm test` und `pnpm build` bei Push/PR aus.

Weitere Informationen zur Beitragserstellung und PR-Checkliste: `CONTRIBUTING.md`.

Docker (schneller Weg, falls du Node/pnpm lokal nicht installieren willst)

```bash
# Build + Start im Container (erstmalig)
docker compose build --progress=plain
docker compose up

# Oder nur im Hintergrund
docker compose up -d

# Logs ansehen
docker compose logs -f

# Stopp
docker compose down
```

Hinweis: Der Container startet per Default `pnpm dev` (dev server + Vite). Die Quelle wird als Volume gemountet, du kannst also im Host weiter editieren.

Ein-Kommando-Start (falls du lieber nicht mehrere Befehle eintippst)

```bash
# Skript erkennt pnpm automatisch oder fällt auf Docker Compose zurück
./scripts/start.sh
```

## Sicherheit & Registrierung

### Rate Limiting

Ein einfaches In-Memory Rate Limiting schützt vor exzessiven Anfragen:

Variablen (in `.env` konfigurierbar):
```
RATE_LIMIT_WINDOW=60000   # Zeitfenster in ms (Standard 60s)
RATE_LIMIT_MAX=10         # Max. Requests pro Fenster & Route
```
Für echte Produktion mit mehreren Instanzen sollte ein externer Store (Redis) genutzt werden.

### Captcha (optional)

Stub-Implementierung (immer gültig solange keine Variablen gesetzt):
```
CAPTCHA_PROVIDER=recaptcha   # oder hcaptcha
CAPTCHA_SECRET=<DEIN_SECRET>
```
Wenn beides fehlt, werden Captcha-Checks übersprungen.

### Formular-Schutzmechanismen

Registrierung (`registration.create`) & Finalisierung (`registration.finalize`) enthalten:
- Honeypot-Feld (muss leer sein)
- Mindest-Ausfüllzeit (≥1.5–2 Sekunden)
- Einmalige Code-Nutzung (Statuswechsel auf `used`)

### Passwort-gestützte Accounts

Das Feld `passwordHash` wurde zur Tabelle `users` hinzugefügt für lokale Accounts (nicht OAuth). Migration ausführen:
```
pnpm run db:push
```

### Erweiterung für Produktion (Empfehlungen)
- Ersetze In-Memory Cache durch persistente DB Tabellen (Registrierungen + Access Logs)
- Implementiere echte Captcha-Verifikation gegen Provider API
- Füge Rate Limiting mit Redis (z. B. Token Bucket) hinzu
- Logging/Monitoring (z. B. Prometheus Exporter oder external APM)
- Passwort-Policy & Bruteforce-Limit für Login-Endpunkt (falls hinzugefügt)

